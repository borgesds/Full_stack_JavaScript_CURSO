=>Abrir o terminal do vs code e dar um comando de init

$ npm init -y

=>Instalar as depend√™ncias que iremos precisar (sequelize e banco de dados) Estamos instalando o express para usar mais na frente, n√£o agora!

$ npm install sequelize pg pg-hstore express

=>Agora iremos fazer a instala√ß√£o do sequelize-cli, que far√° uma organiza√ß√£o b√°sica

$ sudo npm install -g sequelize-cli

$ sudo npm install sequelize-cli -D

=>E agora iremos dar in√≠cio as pastas do nosso projeto, n√£o s√£o todas as pastas que iremos usar inicialmente, mas ao longo do tempo iremos ocupando elas!

$ sequelize-cli init

=>Agora vamos na pasta config, iremos excluir o arquivo dentro dela e criar um novo arquivo, com o mesmo nome s√≥ que JS ‚Äúconfig.js‚Äù e vamos inserir o c√≥digo:

module.exports = {
  dialect: "postgres",
  host: "localhost",
  username: "postgres",
  password: "123456",
  database: "curso_sequelize",
  define: {
    timestamps: true,
  },
};

=>Agora iremos criar o nosso DB com um comando vindo do cli tamb√©m. Voc√™ entra no terminal

$ sequelize db:create


=>Vamos come√ßar com um comando no terminal, na mesma pasta da aula passada!

$ sequelize migration:create --name=planets

=>Ele cria um up e um down j√° com um exemplo aqui em coment√°rio, nos vamos tirar esse exemplo de coment√°rio, tanto de up quanto de down

=>Up, serve para fazer fazer alguma a√ß√£o, nesse caso criar tabelas, o down para voc√™ desfazer coment√°rios, por isso eles precisam ser alterados juntos

=>Vamos primeiro alterar o nome da tabela, que est√° entre ‚Äú‚Äù de users para planets, depois vamos adicionar mais configura√ß√µes dentro dos {} onde est√° inicialmente o id.

up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("planets", { id: Sequelize.INTEGER });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("planets");
  },

=>Vamos agora adicionar informa√ß√µes para a nossa tabela, j√° temos o ID, mas vamos adicionar informa√ß√µes nesse id e tamb√©m outras informa√ß√µes que queremos ter na tabela.

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("planets", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      position: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("planets");
  },
};

=>Agora, iremos dar um comando de terminal para fazer a cria√ß√£o do nosso migrate

$ sequelize db:migrate

=>E agora voc√™ pode verificar no terminal se foi criado com sucesso. Pode tamb√©m ir ver atrav√©s do terminal a cria√ß√£o dele, mas caso queira, temos tamb√©m alternativas visuais, uma delas √© o pgAdmin, que voc√™ pode baixar e configurar por esse link: https://www.pgadmin.org/

=>Voc√™ vendo atrav√©s do pgadmin, pode verificar que tem duas tabelas, uma que voc√™ criou e outra que se chama SequelizeMeta. Nela estar√£o os comandos que voc√™ deu atrav√©s do ‚Äúdb:migrate‚Äù. Isso serve para controle e tamb√©m para o comando para desfazer, que caso voc√™ queira testar agora, basta digitar

$ sequelize db:migrate:undo

=>E agora a sua tabela sumiu, mas dando ‚Äúdb:migrate‚Äù ela vai voltar ao normal. Isso √© √∫til caso voc√™ tenha colocado um item errado. Mas n√£o pode fazer isso depois que j√° foi para produ√ß√£o.

=>Vamos criar dentro da pasta config um arquivo chamado sequelize.js, ele ter√° as configura√ß√µes que iremos usar no topo dos nossos models!

const Sequelize = require("sequelize");
const database = require("./config");

const sequelize = new Sequelize(database);

module.exports = sequelize;

=>Vamos criar um arquivo chamado de ‚ÄúPlanet.js‚Äù dentro de models e tamb√©m vamos criar um arquivo chamado de ‚Äúindex.js‚Äù na raiz do projeto. Primeiro vamos fazer a config de Planet.js

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Planet = sequelize.define("planets", {
  name: DataTypes.STRING,
  position: DataTypes.INTEGER,
});

module.exports = Planet

=>Agora iremos fazer as configura√ß√µes dentro de ‚Äúindex.js‚Äù Para que possamos inserir aqui e fazer outras configs tamb√©m!

(async () => {
  const Planet = require("./models/Planet");

  const newPlanet = await Planet.create({
    name: "Terra",
    position: 3,
  });
  console.log(newPlanet);
})();

=>4. Agora, rodando um comando no terminal, teremos a confirma√ß√£o no pr√≥prio terminal se est√° correto ou n√£o e se foi criado ou n√£o!

$ node index

=>E com isso, voc√™ pode criar quantos planetas quiser, vamos criar mais 2 apenas para ter conte√∫do suficiente para ler quando fizermos o read (Venus e marte)




=>Atualizando valores via sequelize

Vamos fazer aqui mais um m√©todo do CRUD, que √© o de Update, nesse caso, iremos criar um m√©todo para atualizar valores

=>remos aqui come√ßar com a cria√ß√£o desse m√©todo na pasta index.js. Iremos copiar o m√©todo que criamos de achar, para alterar em cima disso!

const updatePlanets = await Planet.findByPk(1);
  updatePlanets.name = "Terra616";

  await updatePlanets.save();
  console.log(updatePlanets);

=>2. Fazendo isso, conseguimos alterar o nome do planeta com ID 1, que antes era s√≥ terra, virou terra 616, que √© uma refer√™ncia para a marvel üòÑ




=>Removendo valores via Sequelize

Agora iremos fazer o D do CRUD, o nosso delete, iremos tamb√©m pegar um pouco do m√©todo de Read, para acharmos o que queremos deletar

=>Iremos copiar o nosso m√©todo Read de novo, para reaproveitar ele, mudando os nomes e colocando apenas algo b√°sico no final

const deletePlanets = await Planet.findByPk(1);
console.log(deletePlanets);

await deletePlanets.destroy();

=>Recomendo sempre que voc√™ tenha muito cuidado ao deletar, sempre preste aten√ß√£o se voc√™ est√° deletando o correto, depois disso, basta colocar o ‚Äúnode index‚Äù que vai ser deletado aquela linha

=>Agora, voc√™ viu o m√©todo CRUD inteiro. E caso queira, pode tamb√©m fazer outros m√©todos de busca pelo que voc√™ quer que deixa at√© mais seguro (com o where buscando pelo name)




==>Transformando em uma API<==

=>Para fazermos requisi√ß√µes, vamos transformar nosso projeto em uma API, faremos via postman, que voc√™ pode encontrar aqui: https://www.postman.com/downloads/. Instale-o antes de continuarmos para as pr√≥ximas etapas para utilizarmos mais √† frente.

=>Vamos criar uma pasta nova chamada ‚Äúsrc‚Äù e dentro dela, colocaremos o nosso arquivo index.js e tamb√©m criaremos um arquivo chamado routes.js

=>Em seguida, vamos criar uma pasta chamada Controllers, e dentro dela, um arquivo chamado ‚ÄúPlanetController.js‚Äù, onde colocaremos os nossos m√©todos CRUD!

=>Vamos fazer a configura√ß√£o de routes.js: nele teremos algumas instru√ß√µes de por onde acessaremos as rotas de CRUD:

const express = require("express");
const routes = express.Router();

const PlanetController = require("../Controllers/PlanetController");


// Rotas de Planets
routes.post("/planets", PlanetController.store);

module.exports = routes;

=>Vamos configurar tamb√©m o arquivo ‚Äúindex.js‚Äù que ter√° algumas informa√ß√µes novas, j√° que iremos separar os m√©todos dentro do controller.

const express = require("express");
const routes = require("./routes");

const app = express();

app.use(express.json());
app.use(routes);

app.listen(3000);

=>Temos o nosso arquivo de rotas criado, ent√£o vamos partir para Controller,onde teremos os nossos m√©todos. O primeiro ser√° POST!

const Planet = require("../models/Planet");

module.exports = {
  async store(req, res) {
    const { name, position } = req.body;

    const planet = await Planet.create({ name, position });

    return res.json(planet);
  },
};

=>Vamos instalar o nodemon, pois √© atrav√©s dele que vamos realizar as requisi√ß√µes. Utilize o comando: npm install¬†nodemon¬†--save-dev. Em seguida, vamos subir o nosso server utilizando o comando ‚Äúnpx nodemon src/index.js‚Äù. No postman, criamos uma pasta chamada API e dentro dela, outra pasta chamada planet, onde faremos uma request chamada de POST, colocando o link: http://localhost:3000/planets

=>Em seguida, voc√™ vai em body > raw  e escolha a op√ß√£o do tipo de arquivo de Text para JSON, para criar um arquivo JSON no body com as informa√ß√µes que precisam ser passadas.

{
"name": "Terra",
"position": 3
}

=>Agora iremos criar um m√©todo GET, que ter√° a busca de todos os planetas. No postman, dentro da pasta, inserimos uma request GET, que ter√° o link ‚Äúhttp://localhost:3000/planets‚Äù.

=>Em routes, iremos adicionar um m√©todo GET com o nome planets.

routes.get("/planets", PlanetController.index);

=>Agora vamos criar o m√©todo findAll em controller,  para buscar todos os planetas.

	async index(req, res) {
    const planets = await Planet.findAll();

    return res.json(planets);
    },

=>Indo no m√©todo GET, criado no postman e clicando em ‚ÄúSEND‚Äù, teremos exatamente o retorno do que queremos, todos os planetas que fizemos at√© agora!

=>Vamos fazer um update de acordo com o ID, criando primeiro a rota, depois o controller.

routes.put("/planets/:id", PlanetController.put);

=>Agora vamos fazer com que o ‚Äú:id‚Äù ache exatamente o planeta que queremos, e com isso, faremos com que seja atualizado apenas o valor espec√≠fico naquele id, para o Controller!

async put(req, res) {
    const { name, size, position } = req.body;
    await Planet.update(
      { name, size, position },
      {
        where: {
          id: req.params.id,
        },
      }
    );
    return res.send("Planet update with sucess");
},

=>Iremos excluir pelo id tamb√©m, de uma forma parecida com a que fizemos com o update! Come√ßando com as rotas!

routes.delete("/planets/:id", PlanetController.delete);

=>E agora vamos alterar o controller, fazendo algo parecido com o que fizemos no update!

async delete(req, res) {
    await Planet.destroy({
      where: {
        id: req.params.id,
      },
    });

    res.send("Sucess! Planet exclude.");
},

=>Vamos criar um request dentro de planet, como fizemos com os outros e colocar o http que inserimos na rota!

http://localhost:3000/planets/3

=>Com isso, temos o nosso CRUD transformado em API e podemos prosseguir para brincar com outros m√©todos e outros tipos de funcionalidades!



=======>Associa√ß√£o Has One<=======

=>Agora vamos fazer um relacionamento hasOne (Tem um - ou um pra um), vamos criar uma nova tabela atrav√©s da migration para armazenar os sat√©lites, pois cada planeta ter√° 1 sat√©lite!

=>Utilize o comando ‚Äúsequelize migration:create ‚Äîname=satelites‚Äù colocando os dados que precisamos e a chave estrangeira tamb√©m!

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("satelites", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      serial_number: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      planetId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "planets", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("satelites");
  },
};

=>Vamos agora criar o model Satelite.js, dentro da pasta models!

const {DataTypes} = require("sequelize");
const sequelize = require("../config/sequelize");

const Satelite = sequelize.define("satelites", {
    name: DataTypes.STRING,
    serial_number: DataTypes.INTEGER,
    planetId: DataTypes.INTEGER,
});

module.exports = Satelite;

=>Em seguida, vamos criar um arquivo dentro de config chamado associations.js, que ter√° as configura√ß√µes de relacionamentos das tabelas!

const Planet = require("../models/Planet");
const Satelite = require("../models/Satelite");

Planet.hasOne(Satelite, { onDelete: "CASCADE", onUpdate: "CASCADE" });
Satelite.belongsTo(Planet, { foreingKey: "planetId", as: "planet" });

module.exports = { Planet, Satelite };

=>Agora, no arquivo index, vamos fazer o require global, para ter na raiz do projeto as conex√µes sendo chamadas.

const express = require("express");
const routes = require("./routes");

require("../config/associations");

const app = express();

app.use(express.json());
app.use(routes);

app.listen(3000);

=>Em routes, vamos fazer a rota de cria√ß√£o de um sat√©lite para um planeta espec√≠fico, passando o ID dele!

routes.post("/planet/:planetId/satelites", SateliteController.store);

=>Em SateliteController, vamos criar o m√©todo store, que ser√° respons√°vel por armazenar os dados e vamos utilizar testando o m√©todo POST:

const Satelite = require("../../models/Satelite");
const Planet = require("../../models/Planet");

module.exports = {
  async store(req, res) {
    const { planetId } = req.params;
    const { name, serial_number } = req.body;

    const planet = await Planet.findByPk(planetId);

    if (!planet) {
      res.send("Esse planeta n√£o existe!");
    }

    const satelite = await Satelite.create({ name, serial_number, planetId });

    return res.json(satelite);
  },
};

=>Vamos testar no postman e verificar se est√° funcionando: - Antes de come√ßarmos os testes, precisamos iniciar o servidor do nodemon: npx nodemon src/index.js. 

- Crie uma nova pasta chamada Satelites para deixar mais organizado, em seguida, criaremos um m√©todo GET dentro dela, com a url: http://localhost:3000/planet/5/satelites. Conseguiremos ver o retorno de todos os planetas e satelites relacionados a ele.

Ainda n√£o temos nenhum, ent√£o vamos criar um m√©todo POST para cadastrar os satelites:

- Crie o m√©todo post e coloque a url que definimos na rota: [http://localhost:3000/planet/10/satelites](http://localhost:3000/planet/10/satelites) e como vamos inserir dados no banco, precisamos passar os par√¢metros no body, escolha a op√ß√£o JSON e coloque os seguintes par√¢metros:

{
"name" : "XYSZ",
"serial_number": 1234659846
}

=>Vamos no arquivo routes.js, criar a rota de satelites para o index:

routes.get("/planet/:planetId/satelites", SateliteController.index);

=>Agora vamos em SateliteController fazer a cria√ß√£o de um m√©todo para o index.

async index(req,res) {
        const {planetId} = await req.params;

        if(!planetId){
            res.send("Esse Planeta n√£o existe!");
        }

        const planet = await Planet.findByPk(planetId, {
            include: Satelite,
        });

        return res.json(planet);

    },

=>Agora vamos testar no postman, utilizando o m√©todo GET:

- Vamos rodar nossa url: http://localhost:3000/planet/5/satelites. Conseguiremos ver o retorno de todos os planetas e satelites relacionados a ele, vamos buscar por planetas e se ele n√£o existir, vai aparecer uma mensagem de alerta.
- Para inserir um sat√©lite, vamos criar um m√©todo POST e inserir no body, o seguinte Json:

{
    "name" : "XYSZ",
    "serial_number": 1234659846

}

- Se quisermos ver apenas o satelite, vamos acrescentar no return, a informa√ß√£o:

return res.json(planet.satelite);

=>Agora j√° temos um hasOne funcionando na nossa API

=====>[RESOLU√á√ÉO] Associa√ß√£o Many to Many<=====

=>Vamos come√ßar criando uma migrate para caps

$ sequelize migration:create --name=caps

=>Agora vamos criar uma tabela da mesma forma para spaceships

$ sequelize migration:create --name=spaceships

=>Agora iremos criar a tabela ‚Äúpiv√¥‚Äù, chamada de capsSpaceships

$ sequelize migration:create --name=capSpaceships

=>Agora faremos nossa as migrations por ordem, primeiro caps

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("caps", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      registerNumber: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("caps");
  },
};

=>Agora a migration de spaceship

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("spaceships", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      capacity: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("spaceships");
  },
};

=>Agora a migration de capSpaceship

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("capSpaceship", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      capId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "caps", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      spaceshipId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "spaceships", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("capSpaceship");
  },
};

=>Agora vamos criar os models, vamos criar Cap e Spaceship, n√£o √© necess√°rio model para o piv√¥, pois ele ser√° autom√°tico com os Ids. Primeiro vamos configurar Cap

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Cap = sequelize.define("caps", {
  name: DataTypes.STRING,
  registerNumber: DataTypes.STRING,
});

module.exports = Cap;

=>Agora vamos fazer o model de Spaceship

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Spaceship = sequelize.define("spaceships", {
  name: DataTypes.STRING,
  capacity: DataTypes.INTEGER,
});

module.exports = Spaceship;

=>Agora iremos l√° em associations para fazer a associa√ß√£o deles como Many to Many

const Cap = require("../models/Cap");
const Spaceship = require("../models/Spaceship");

Cap.belongsToMany(Spaceship, {
  foreingKey: "capId",
  through: "capSpaceship",
  as: "spaceships",
});

Spaceship.belongsToMany(Cap, {
  foreingKey: "spaceshipId",
  through: "capSpaceship",
  as: "caps",
});

=>Agora faremos a cria√ß√£o das tabelas por cli

$ sequelize db:migrate

=>Agora vamos criar os dois controllers, e importar eles dentro de routes

const CapController = require("./controllers/CapController");
const SpaceshipController = require("./controllers/SpaceshipController");

=>Vamos primeiro fazer a rota de cria√ß√£o de listagem de cap, as duas de uma vez!

routes.post("/cap", CapController.store);
routes.get("/cap", CapController.index);

=>Agora vamos criar os controllers no CapController, ambos tamb√©m de uma vez, para agilizar

const Cap = require("../models/Cap");

module.exports = {
  async store(req, res) {
    const { name, registerNumber } = req.body;

    const cap = await Cap.create({ name, registerNumber });

    return res.json(cap);
  },
  async index(req, res) {
    const cap = await Cap.findAll();

    return res.json(cap);
  },
};

=>E agora voc√™ pode testar, criando dois caps e tamb√©m vendo se eles s√£o listados! No postman, crie uma pasta chamada CAPS e o m√©todo GET, colocando a url: http://localhost:3000/cap

=>Se quisermos criar um capit√£o, criamos um m√©todo post com a url: http://localhost:3000/cap e no body, inserimos o json:

{
"name": "Armstrong",
"registerNumber": 87984984
}

=>Vamos agora para as rotas de spaceship!

routes.post("/caps/:capId/spaceships", SpaceshipController.store);
routes.get("/caps/:capId/spaceships", SpaceshipController.index);

=>Vamos fazer tamb√©m esses m√©todos (SpaceshipController, ambos de uma s√≥ vez!

const Spaceship = require("../models/Spaceship");
const Cap = require("../models/Cap");

module.exports = {
  async store(req, res) {
    const { capId } = req.params;
    const { name, capacity } = req.body;

    const cap = await Cap.findByPk(capId);

    if (!cap) {
      res.send("Error, this cap does not exist!");
    }

    const [spaceships] = await Spaceship.findOrCreate({
      where: { name, capacity },
    });

    await cap.addSpaceship(spaceships);

    return res.json(spaceships);
  },
  async index(req, res) {
    const { capId } = req.params;

    const cap = await Cap.findByPk(capId, {
      include: { association: "spaceships" },
    });

    return res.json(cap);
  },
};

=>Dentro do arquivo association pode esta faltando a associa√ß√£o dos arquivos:



=>Vamos testar no postman, utilizando o m√©todo GET, com a url:  http://localhost:3000/caps/2/spaceships e para inserir uma spaceship, no m√©todo post, vamos colocar a url: http://localhost:3000/caps/1/spaceships e no body, insira o Json:

=>{
    "name": "Apollo 11",
    "capacity": 10
}

=>Com isso, voc√™ consegue criar e ver tranquilamente, podemos tamb√©m fazer a passagem de m√©todo ‚Äúcap.spaceships‚Äù para vermos apenas as spaceships, e voc√™ vai notar que dentro de spaceships tem um capSpaceships, mostrando como foi feito o piv√¥ entre eles.

=>Crie 3 caps e 3 spaceships para cada cap, tamb√©m fa√ßa uma brincadeira, voc√™ pode fazer com que a 1 nave, seja pertencente a 3 caps, para que dessa forma voc√™ veja, tanto no pgadmin quanto no m√©todo get que o Many to Many est√° sendo aplicado com sucesso!