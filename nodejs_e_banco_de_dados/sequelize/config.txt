=>Abrir o terminal do vs code e dar um comando de init

$ npm init -y

=>Instalar as dependÃªncias que iremos precisar (sequelize e banco de dados) Estamos instalando o express para usar mais na frente, nÃ£o agora!

$ npm install sequelize pg pg-hstore express

=>Agora iremos fazer a instalaÃ§Ã£o do sequelize-cli, que farÃ¡ uma organizaÃ§Ã£o bÃ¡sica

$ sudo npm install -g sequelize-cli

$ sudo npm install sequelize-cli -D

=>E agora iremos dar inÃ­cio as pastas do nosso projeto, nÃ£o sÃ£o todas as pastas que iremos usar inicialmente, mas ao longo do tempo iremos ocupando elas!

$ sequelize-cli init

=>Agora vamos na pasta config, iremos excluir o arquivo dentro dela e criar um novo arquivo, com o mesmo nome sÃ³ que JS â€œconfig.jsâ€ e vamos inserir o cÃ³digo:

module.exports = {
  dialect: "postgres",
  host: "localhost",
  username: "postgres",
  password: "123456",
  database: "curso_sequelize",
  define: {
    timestamps: true,
  },
};

=>Agora iremos criar o nosso DB com um comando vindo do cli tambÃ©m. VocÃª entra no terminal

$ sequelize db:create


=>Vamos comeÃ§ar com um comando no terminal, na mesma pasta da aula passada!

$ sequelize migration:create --name=planets

=>Ele cria um up e um down jÃ¡ com um exemplo aqui em comentÃ¡rio, nos vamos tirar esse exemplo de comentÃ¡rio, tanto de up quanto de down

=>Up, serve para fazer fazer alguma aÃ§Ã£o, nesse caso criar tabelas, o down para vocÃª desfazer comentÃ¡rios, por isso eles precisam ser alterados juntos

=>Vamos primeiro alterar o nome da tabela, que estÃ¡ entre â€œâ€ de users para planets, depois vamos adicionar mais configuraÃ§Ãµes dentro dos {} onde estÃ¡ inicialmente o id.

up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("planets", { id: Sequelize.INTEGER });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("planets");
  },

=>Vamos agora adicionar informaÃ§Ãµes para a nossa tabela, jÃ¡ temos o ID, mas vamos adicionar informaÃ§Ãµes nesse id e tambÃ©m outras informaÃ§Ãµes que queremos ter na tabela.

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("planets", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      position: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("planets");
  },
};

=>Agora, iremos dar um comando de terminal para fazer a criaÃ§Ã£o do nosso migrate

$ sequelize db:migrate

=>E agora vocÃª pode verificar no terminal se foi criado com sucesso. Pode tambÃ©m ir ver atravÃ©s do terminal a criaÃ§Ã£o dele, mas caso queira, temos tambÃ©m alternativas visuais, uma delas Ã© o pgAdmin, que vocÃª pode baixar e configurar por esse link: https://www.pgadmin.org/

=>VocÃª vendo atravÃ©s do pgadmin, pode verificar que tem duas tabelas, uma que vocÃª criou e outra que se chama SequelizeMeta. Nela estarÃ£o os comandos que vocÃª deu atravÃ©s do â€œdb:migrateâ€. Isso serve para controle e tambÃ©m para o comando para desfazer, que caso vocÃª queira testar agora, basta digitar

$ sequelize db:migrate:undo

=>E agora a sua tabela sumiu, mas dando â€œdb:migrateâ€ ela vai voltar ao normal. Isso Ã© Ãºtil caso vocÃª tenha colocado um item errado. Mas nÃ£o pode fazer isso depois que jÃ¡ foi para produÃ§Ã£o.

=>Vamos criar dentro da pasta config um arquivo chamado sequelize.js, ele terÃ¡ as configuraÃ§Ãµes que iremos usar no topo dos nossos models!

const Sequelize = require("sequelize");
const database = require("./config");

const sequelize = new Sequelize(database);

module.exports = sequelize;

=>Vamos criar um arquivo chamado de â€œPlanet.jsâ€ dentro de models e tambÃ©m vamos criar um arquivo chamado de â€œindex.jsâ€ na raiz do projeto. Primeiro vamos fazer a config de Planet.js

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Planet = sequelize.define("planets", {
  name: DataTypes.STRING,
  position: DataTypes.INTEGER,
});

module.exports = Planet

=>Agora iremos fazer as configuraÃ§Ãµes dentro de â€œindex.jsâ€ Para que possamos inserir aqui e fazer outras configs tambÃ©m!

(async () => {
  const Planet = require("./models/Planet");

  const newPlanet = await Planet.create({
    name: "Terra",
    position: 3,
  });
  console.log(newPlanet);
})();

=>4. Agora, rodando um comando no terminal, teremos a confirmaÃ§Ã£o no prÃ³prio terminal se estÃ¡ correto ou nÃ£o e se foi criado ou nÃ£o!

$ node index

=>E com isso, vocÃª pode criar quantos planetas quiser, vamos criar mais 2 apenas para ter conteÃºdo suficiente para ler quando fizermos o read (Venus e marte)




=>Atualizando valores via sequelize

Vamos fazer aqui mais um mÃ©todo do CRUD, que Ã© o de Update, nesse caso, iremos criar um mÃ©todo para atualizar valores

=>remos aqui comeÃ§ar com a criaÃ§Ã£o desse mÃ©todo na pasta index.js. Iremos copiar o mÃ©todo que criamos de achar, para alterar em cima disso!

const updatePlanets = await Planet.findByPk(1);
  updatePlanets.name = "Terra616";

  await updatePlanets.save();
  console.log(updatePlanets);

=>2. Fazendo isso, conseguimos alterar o nome do planeta com ID 1, que antes era sÃ³ terra, virou terra 616, que Ã© uma referÃªncia para a marvel ğŸ˜„




=>Removendo valores via Sequelize

Agora iremos fazer o D do CRUD, o nosso delete, iremos tambÃ©m pegar um pouco do mÃ©todo de Read, para acharmos o que queremos deletar

=>Iremos copiar o nosso mÃ©todo Read de novo, para reaproveitar ele, mudando os nomes e colocando apenas algo bÃ¡sico no final

const deletePlanets = await Planet.findByPk(1);
console.log(deletePlanets);

await deletePlanets.destroy();

=>Recomendo sempre que vocÃª tenha muito cuidado ao deletar, sempre preste atenÃ§Ã£o se vocÃª estÃ¡ deletando o correto, depois disso, basta colocar o â€œnode indexâ€ que vai ser deletado aquela linha

=>Agora, vocÃª viu o mÃ©todo CRUD inteiro. E caso queira, pode tambÃ©m fazer outros mÃ©todos de busca pelo que vocÃª quer que deixa atÃ© mais seguro (com o where buscando pelo name)




==>Transformando em uma API<==

=>Para fazermos requisiÃ§Ãµes, vamos transformar nosso projeto em uma API, faremos via postman, que vocÃª pode encontrar aqui: https://www.postman.com/downloads/. Instale-o antes de continuarmos para as prÃ³ximas etapas para utilizarmos mais Ã  frente.

=>Vamos criar uma pasta nova chamada â€œsrcâ€ e dentro dela, colocaremos o nosso arquivo index.js e tambÃ©m criaremos um arquivo chamado routes.js

=>Em seguida, vamos criar uma pasta chamada Controllers, e dentro dela, um arquivo chamado â€œPlanetController.jsâ€, onde colocaremos os nossos mÃ©todos CRUD!

=>Vamos fazer a configuraÃ§Ã£o de routes.js: nele teremos algumas instruÃ§Ãµes de por onde acessaremos as rotas de CRUD:

const express = require("express");
const routes = express.Router();

const PlanetController = require("../Controllers/PlanetController");


// Rotas de Planets
routes.post("/planets", PlanetController.store);

module.exports = routes;

=>Vamos configurar tambÃ©m o arquivo â€œindex.jsâ€ que terÃ¡ algumas informaÃ§Ãµes novas, jÃ¡ que iremos separar os mÃ©todos dentro do controller.

const express = require("express");
const routes = require("./routes");

const app = express();

app.use(express.json());
app.use(routes);

app.listen(3000);

=>Temos o nosso arquivo de rotas criado, entÃ£o vamos partir para Controller,onde teremos os nossos mÃ©todos. O primeiro serÃ¡ POST!

const Planet = require("../models/Planet");

module.exports = {
  async store(req, res) {
    const { name, position } = req.body;

    const planet = await Planet.create({ name, position });

    return res.json(planet);
  },
};

=>Vamos instalar o nodemon, pois Ã© atravÃ©s dele que vamos realizar as requisiÃ§Ãµes. Utilize o comando: npm installÂ nodemonÂ --save-dev. Em seguida, vamos subir o nosso server utilizando o comando â€œnpx nodemon src/index.jsâ€. No postman, criamos uma pasta chamada API e dentro dela, outra pasta chamada planet, onde faremos uma request chamada de POST, colocando o link: http://localhost:3000/planets

=>Em seguida, vocÃª vai em body > raw  e escolha a opÃ§Ã£o do tipo de arquivo de Text para JSON, para criar um arquivo JSON no body com as informaÃ§Ãµes que precisam ser passadas.

{
"name": "Terra",
"position": 3
}

=>Agora iremos criar um mÃ©todo GET, que terÃ¡ a busca de todos os planetas. No postman, dentro da pasta, inserimos uma request GET, que terÃ¡ o link â€œhttp://localhost:3000/planetsâ€.

=>Em routes, iremos adicionar um mÃ©todo GET com o nome planets.

routes.get("/planets", PlanetController.index);

=>Agora vamos criar o mÃ©todo findAll em controller,  para buscar todos os planetas.

	async index(req, res) {
    const planets = await Planet.findAll();

    return res.json(planets);
    },

=>Indo no mÃ©todo GET, criado no postman e clicando em â€œSENDâ€, teremos exatamente o retorno do que queremos, todos os planetas que fizemos atÃ© agora!

=>Vamos fazer um update de acordo com o ID, criando primeiro a rota, depois o controller.

routes.put("/planets/:id", PlanetController.put);

=>Agora vamos fazer com que o â€œ:idâ€ ache exatamente o planeta que queremos, e com isso, faremos com que seja atualizado apenas o valor especÃ­fico naquele id, para o Controller!

async put(req, res) {
    const { name, size, position } = req.body;
    await Planet.update(
      { name, size, position },
      {
        where: {
          id: req.params.id,
        },
      }
    );
    return res.send("Planet update with sucess");
},

=>Iremos excluir pelo id tambÃ©m, de uma forma parecida com a que fizemos com o update! ComeÃ§ando com as rotas!

routes.delete("/planets/:id", PlanetController.delete);

=>E agora vamos alterar o controller, fazendo algo parecido com o que fizemos no update!

async delete(req, res) {
    await Planet.destroy({
      where: {
        id: req.params.id,
      },
    });

    res.send("Sucess! Planet exclude.");
},

=>Vamos criar um request dentro de planet, como fizemos com os outros e colocar o http que inserimos na rota!

http://localhost:3000/planets/3

=>Com isso, temos o nosso CRUD transformado em API e podemos prosseguir para brincar com outros mÃ©todos e outros tipos de funcionalidades!



=======>AssociaÃ§Ã£o Has One<=======

=>Agora vamos fazer um relacionamento hasOne (Tem um - ou um pra um), vamos criar uma nova tabela atravÃ©s da migration para armazenar os satÃ©lites, pois cada planeta terÃ¡ 1 satÃ©lite!

=>Utilize o comando â€œsequelize migration:create â€”name=satelitesâ€ colocando os dados que precisamos e a chave estrangeira tambÃ©m!

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("satelites", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      serial_number: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      planetId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "planets", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("satelites");
  },
};

=>Vamos agora criar o model Satelite.js, dentro da pasta models!

const {DataTypes} = require("sequelize");
const sequelize = require("../config/sequelize");

const Satelite = sequelize.define("satelites", {
    name: DataTypes.STRING,
    serial_number: DataTypes.INTEGER,
    planetId: DataTypes.INTEGER,
});

module.exports = Satelite;

=>Em seguida, vamos criar um arquivo dentro de config chamado associations.js, que terÃ¡ as configuraÃ§Ãµes de relacionamentos das tabelas!

const Planet = require("../models/Planet");
const Satelite = require("../models/Satelite");

Planet.hasOne(Satelite, { onDelete: "CASCADE", onUpdate: "CASCADE" });
Satelite.belongsTo(Planet, { foreingKey: "planetId", as: "planet" });

module.exports = { Planet, Satelite };

=>Agora, no arquivo index, vamos fazer o require global, para ter na raiz do projeto as conexÃµes sendo chamadas.

const express = require("express");
const routes = require("./routes");

require("../config/associations");

const app = express();

app.use(express.json());
app.use(routes);

app.listen(3000);

=>Em routes, vamos fazer a rota de criaÃ§Ã£o de um satÃ©lite para um planeta especÃ­fico, passando o ID dele!

routes.post("/planet/:planetId/satelites", SateliteController.store);

=>Em SateliteController, vamos criar o mÃ©todo store, que serÃ¡ responsÃ¡vel por armazenar os dados e vamos utilizar testando o mÃ©todo POST:

const Satelite = require("../../models/Satelite");
const Planet = require("../../models/Planet");

module.exports = {
  async store(req, res) {
    const { planetId } = req.params;
    const { name, serial_number } = req.body;

    const planet = await Planet.findByPk(planetId);

    if (!planet) {
      res.send("Esse planeta nÃ£o existe!");
    }

    const satelite = await Satelite.create({ name, serial_number, planetId });

    return res.json(satelite);
  },
};

=>Vamos testar no postman e verificar se estÃ¡ funcionando: - Antes de comeÃ§armos os testes, precisamos iniciar o servidor do nodemon: npx nodemon src/index.js. 

- Crie uma nova pasta chamada Satelites para deixar mais organizado, em seguida, criaremos um mÃ©todo GET dentro dela, com a url: http://localhost:3000/planet/5/satelites. Conseguiremos ver o retorno de todos os planetas e satelites relacionados a ele.

Ainda nÃ£o temos nenhum, entÃ£o vamos criar um mÃ©todo POST para cadastrar os satelites:

- Crie o mÃ©todo post e coloque a url que definimos na rota: [http://localhost:3000/planet/10/satelites](http://localhost:3000/planet/10/satelites) e como vamos inserir dados no banco, precisamos passar os parÃ¢metros no body, escolha a opÃ§Ã£o JSON e coloque os seguintes parÃ¢metros:

{
"name" : "XYSZ",
"serial_number": 1234659846
}

=>Vamos no arquivo routes.js, criar a rota de satelites para o index:

routes.get("/planet/:planetId/satelites", SateliteController.index);

=>Agora vamos em SateliteController fazer a criaÃ§Ã£o de um mÃ©todo para o index.

async index(req,res) {
        const {planetId} = await req.params;

        if(!planetId){
            res.send("Esse Planeta nÃ£o existe!");
        }

        const planet = await Planet.findByPk(planetId, {
            include: Satelite,
        });

        return res.json(planet);

    },

=>Agora vamos testar no postman, utilizando o mÃ©todo GET:

- Vamos rodar nossa url: http://localhost:3000/planet/5/satelites. Conseguiremos ver o retorno de todos os planetas e satelites relacionados a ele, vamos buscar por planetas e se ele nÃ£o existir, vai aparecer uma mensagem de alerta.
- Para inserir um satÃ©lite, vamos criar um mÃ©todo POST e inserir no body, o seguinte Json:

{
    "name" : "XYSZ",
    "serial_number": 1234659846

}

- Se quisermos ver apenas o satelite, vamos acrescentar no return, a informaÃ§Ã£o:

return res.json(planet.satelite);

=>Agora jÃ¡ temos um hasOne funcionando na nossa API

=====>[RESOLUÃ‡ÃƒO] AssociaÃ§Ã£o Many to Many<=====

=>Vamos comeÃ§ar criando uma migrate para caps

$ sequelize migration:create --name=caps

=>Agora vamos criar uma tabela da mesma forma para spaceships

$ sequelize migration:create --name=spaceships

=>Agora iremos criar a tabela â€œpivÃ´â€, chamada de capsSpaceships

$ sequelize migration:create --name=capSpaceships

=>Agora faremos nossa as migrations por ordem, primeiro caps

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("caps", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      registerNumber: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("caps");
  },
};

=>Agora a migration de spaceship

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("spaceships", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      capacity: {
        type: Sequelize.INTEGER,
        allowNull: false,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("spaceships");
  },
};

=>Agora a migration de capSpaceship

"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("capSpaceship", {
      id: {
        type: Sequelize.INTEGER,
        autoIncrement: true,
        allowNull: false,
        primaryKey: true,
      },
      capId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "caps", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      spaceshipId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "spaceships", key: "id" },
        onUpdate: "CASCADE",
        onDelete: "CASCADE",
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("capSpaceship");
  },
};

=>Agora vamos criar os models, vamos criar Cap e Spaceship, nÃ£o Ã© necessÃ¡rio model para o pivÃ´, pois ele serÃ¡ automÃ¡tico com os Ids. Primeiro vamos configurar Cap

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Cap = sequelize.define("caps", {
  name: DataTypes.STRING,
  registerNumber: DataTypes.STRING,
});

module.exports = Cap;

=>Agora vamos fazer o model de Spaceship

const { DataTypes } = require("sequelize");
const sequelize = require("../config/sequelize");

const Spaceship = sequelize.define("spaceships", {
  name: DataTypes.STRING,
  capacity: DataTypes.INTEGER,
});

module.exports = Spaceship;

=>Agora iremos lÃ¡ em associations para fazer a associaÃ§Ã£o deles como Many to Many

const Cap = require("../models/Cap");
const Spaceship = require("../models/Spaceship");

Cap.belongsToMany(Spaceship, {
  foreingKey: "capId",
  through: "capSpaceship",
  as: "spaceships",
});

Spaceship.belongsToMany(Cap, {
  foreingKey: "spaceshipId",
  through: "capSpaceship",
  as: "caps",
});

=>Agora faremos a criaÃ§Ã£o das tabelas por cli

$ sequelize db:migrate

=>Agora vamos criar os dois controllers, e importar eles dentro de routes

const CapController = require("./controllers/CapController");
const SpaceshipController = require("./controllers/SpaceshipController");

=>Vamos primeiro fazer a rota de criaÃ§Ã£o de listagem de cap, as duas de uma vez!

routes.post("/cap", CapController.store);
routes.get("/cap", CapController.index);

=>Agora vamos criar os controllers no CapController, ambos tambÃ©m de uma vez, para agilizar

const Cap = require("../models/Cap");

module.exports = {
  async store(req, res) {
    const { name, registerNumber } = req.body;

    const cap = await Cap.create({ name, registerNumber });

    return res.json(cap);
  },
  async index(req, res) {
    const cap = await Cap.findAll();

    return res.json(cap);
  },
};

=>E agora vocÃª pode testar, criando dois caps e tambÃ©m vendo se eles sÃ£o listados! No postman, crie uma pasta chamada CAPS e o mÃ©todo GET, colocando a url: http://localhost:3000/cap

=>Se quisermos criar um capitÃ£o, criamos um mÃ©todo post com a url: http://localhost:3000/cap e no body, inserimos o json:

{
"name": "Armstrong",
"registerNumber": 87984984
}

=>Vamos agora para as rotas de spaceship!

routes.post("/caps/:capId/spaceships", SpaceshipController.store);
routes.get("/caps/:capId/spaceships", SpaceshipController.index);

=>Vamos fazer tambÃ©m esses mÃ©todos (SpaceshipController, ambos de uma sÃ³ vez!

const Spaceship = require("../models/Spaceship");
const Cap = require("../models/Cap");

module.exports = {
  async store(req, res) {
    const { capId } = req.params;
    const { name, capacity } = req.body;

    const cap = await Cap.findByPk(capId);

    if (!cap) {
      res.send("Error, this cap does not exist!");
    }

    const [spaceships] = await Spaceship.findOrCreate({
      where: { name, capacity },
    });

    await cap.addSpaceship(spaceships);

    return res.json(spaceships);
  },
  async index(req, res) {
    const { capId } = req.params;

    const cap = await Cap.findByPk(capId, {
      include: { association: "spaceships" },
    });

    return res.json(cap);
  },
};

=>Dentro do arquivo association pode esta faltando a associaÃ§Ã£o dos arquivos:



=>Vamos testar no postman, utilizando o mÃ©todo GET, com a url:  http://localhost:3000/caps/2/spaceships e para inserir uma spaceship, no mÃ©todo post, vamos colocar a url: http://localhost:3000/caps/1/spaceships e no body, insira o Json:

=>{
    "name": "Apollo 11",
    "capacity": 10
}

=>Com isso, vocÃª consegue criar e ver tranquilamente, podemos tambÃ©m fazer a passagem de mÃ©todo â€œcap.spaceshipsâ€ para vermos apenas as spaceships, e vocÃª vai notar que dentro de spaceships tem um capSpaceships, mostrando como foi feito o pivÃ´ entre eles.

=>Crie 3 caps e 3 spaceships para cada cap, tambÃ©m faÃ§a uma brincadeira, vocÃª pode fazer com que a 1 nave, seja pertencente a 3 caps, para que dessa forma vocÃª veja, tanto no pgadmin quanto no mÃ©todo get que o Many to Many estÃ¡ sendo aplicado com sucesso!